FUNCTION_BLOCK "_UtilitiesFB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      CPUSytemMemoryBits { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Byte;   // Address of system memory byte
      CPUClockMemoryBits { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Byte;   // Address of clock memory byte
      StartupDelaySP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;   // Delay before startup delay bit turned on
   END_VAR

   VAR 
      AlwaysOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always TRUE
      AlwaysTrue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always TRUE
      AlwaysOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always FALSE
      AlwaysFalse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit always FALSE
      FirstScan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE for only the first scan of the PLC
      StartupDelayDn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit initially FALSE, turning TRUE after preset delay
      StartupDelayTmr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;
      Square_100ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (100 ms frequency)
      Square_100msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_100ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 100 ms for one PLC scan
      Square_200ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (200 ms frequency)
      Square_200msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_200ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 200 ms for one PLC scan
      Square_400ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (400 ms frequency)
      Square_400msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_400ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 400 ms for one PLC scan
      Square_500ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (500 ms frequency)
      Square_500msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_500ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 500 ms for one PLC scan
      Square_800ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (800 ms frequency)
      Square_800msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_800ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 800 ms for one PLC scan
      Square_1s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (1 s frequency)
      Square_1sONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_1s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 1 s for one PLC scan
      Square_1600ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (1600 ms frequency)
      Square_1600msONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_1600ms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 1600 ms for one PLC scan
      Square_2s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit FALSE/TRUE based on square wave (2 s frequency)
      Square_2sONS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
      Pulse_2s { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Bit TRUE every 2 s for one PLC scan
      TestInProgress { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Indicates which caller FC is used
      EPICS_Device_calls_precessed { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;   // Indicates which caller FC is used
   END_VAR

BEGIN
	//This block provides standard "Utilities" tags that can be used in the rest OF the PLC code such
	//as:
	//* Always On
	//* Always Off
	//* Startup Delay
	//* Pulses (different frequences)
	//* etc.
	
	//When using This block in your program, name the instance DB "Utilities" AND THEN you will be able TO use tags like "Utilities.AlwaysOn" in the rest OF your program.
	
	//This block relies On information provided BY the CPU. This needs TO be enabled in the CPU hardware configuration under System AND Clock Memory.
	//Enable both functions AND pick memory bytes you'd like TO use (defauls are %MB1 AND %MB0 respectively).
	//THEN connect the selected Byte TO the inputs OF This block.
	//
	
	//Bit TRUE for only the first scan of the PLC
	#FirstScan := #CPUSytemMemoryBits.%X0;
	
	//Bit always TRUE
	#AlwaysOn := #CPUSytemMemoryBits.%X2;
	#AlwaysTrue := #CPUSytemMemoryBits.%X2;
	
	//Bit always FALSE
	#AlwaysOff := #CPUSytemMemoryBits.%X3;
	#AlwaysFalse := #CPUSytemMemoryBits.%X3;
	
	//Bit initially FALSE, turning TRUE after preset delay
	#StartupDelayTmr.TON(IN := #AlwaysTrue,
	                     PT := #StartupDelaySP,
	                     Q => #StartupDelayDn);
	
	//Bit TRUE every 100 ms FOR one PLC scan
	#Square_100ms := #CPUClockMemoryBits.%X0;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_100ms,
	              "iq_Trigger Bit" := #Square_100msONS,
	              "iq_Pulse Bit" := #Pulse_100ms);
	
	//Bit TRUE every 200 ms FOR one PLC scan
	#Square_200ms := #CPUClockMemoryBits.%X1;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_200ms,
	              "iq_Trigger Bit" := #Square_200msONS,
	              "iq_Pulse Bit" := #Pulse_200ms);
	
	//Bit TRUE every 400 ms FOR one PLC scan
	#Square_400ms := #CPUClockMemoryBits.%X2;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_400ms,
	              "iq_Trigger Bit" := #Square_400msONS,
	              "iq_Pulse Bit" := #Pulse_400ms);
	
	//Bit TRUE every 500 ms FOR one PLC scan
	#Square_500ms := #CPUClockMemoryBits.%X3;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_500ms,
	              "iq_Trigger Bit" := #Square_500msONS,
	              "iq_Pulse Bit" := #Pulse_500ms);
	
	//Bit TRUE every 800 ms FOR one PLC scan
	#Square_800ms := #CPUClockMemoryBits.%X4;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_800ms,
	              "iq_Trigger Bit" := #Square_800msONS,
	              "iq_Pulse Bit" := #Pulse_800ms);
	
	//Bit TRUE every 1 s FOR one PLC scan
	#Square_1s := #CPUClockMemoryBits.%X5;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_1s,
	              "iq_Trigger Bit" := #Square_1sONS,
	              "iq_Pulse Bit" := #Pulse_1s);
	
	//Bit TRUE every 1600 ms FOR one PLC scan
	#Square_1600ms := #CPUClockMemoryBits.%X6;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_1600ms,
	              "iq_Trigger Bit" := #Square_1600msONS,
	              "iq_Pulse Bit" := #Pulse_1600ms);
	
	//Bit TRUE every 2s FOR one PLC scan
	#Square_2s := #CPUClockMemoryBits.%X7;
	"UTIL_P_TRIG"("i_Input Bit" := #Square_2s,
	              "iq_Trigger Bit" := #Square_2sONS,
	              "iq_Pulse Bit" := #Pulse_2s);
	
END_FUNCTION_BLOCK
DATA_BLOCK "Utilities"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"_UtilitiesFB"

BEGIN

END_DATA_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_BDump"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrFlowOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_BDump
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  LEBT Beam Dump  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"WtrFlowOK";    //EPICSName: WtrFlowOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_CHOP"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "PwrSysOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: PwrSysOK
      "ChopVoltAlarmR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ChopVoltAlarmR
      "WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrFlowOK
      "HVEnCmdRB" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVEnCmdRB
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "HVEnOnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: HVEnOnCmd
      "HVEnOffCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: HVEnOffCmd
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_CHOP
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  LEBT Chopper  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"PwrSysOK";    //EPICSName: PwrSysOK
       #MyBoolsinWord[9] := #"ChopVoltAlarmR";    //EPICSName: ChopVoltAlarmR
       #MyBoolsinWord[10] := #"WtrFlowOK";    //EPICSName: WtrFlowOK
       #MyBoolsinWord[11] := #"HVEnCmdRB";    //EPICSName: HVEnCmdRB
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       IF (NOT "Utilities".TestInProgress) THEN
       	"EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       END_IF;
       #"HVEnOnCmd" := #MyBoolsinWord[8];    //EPICSName: HVEnOnCmd
       #"HVEnOffCmd" := #MyBoolsinWord[9];    //EPICSName: HVEnOffCmd
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_COIL_SOLENOID"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrFlowOK
      "WtrTempOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrTempOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_COIL_SOLENOID
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT Coils and Solenoids Water Flow and Temperature Status  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"WtrFlowOK";    //EPICSName: WtrFlowOK
       #MyBoolsinWord[9] := #"WtrTempOK";    //EPICSName: WtrTempOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_COLL"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrFlowOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_COLL
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  LEBT Collimator  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"WtrFlowOK";    //EPICSName: WtrFlowOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_HVIT"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "LidOpenR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: LidOpenR
      "OilTempOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OilTempOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_HVIT
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC HV Isolation Transformer  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"LidOpenR";    //EPICSName: LidOpenR
       #MyBoolsinWord[9] := #"OilTempOK";    //EPICSName: OilTempOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_HVPS"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "ITLckEnCmdR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ITLckEnCmdR
      "HVPSVolOK_Magtr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVPSVolOK_Magtr
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "ESTOP" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: ESTOP
      "iVolR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: iVolR
      "EPICSConnErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Parameter variable: EPICSConnErr
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_HVPS
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISrc HVPS  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"ITLckEnCmdR";    //EPICSName: ITLckEnCmdR
       #MyBoolsinWord[9] := #"HVPSVolOK_Magtr";    //EPICSName: HVPSVolOK_Magtr
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       IF (NOT "Utilities".TestInProgress) THEN
       	"EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       END_IF;
       #"ESTOP" := #MyBoolsinWord[8];    //EPICSName: ESTOP

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 2];
       #"iVolR" := #MyReal;    //EPICSName: iVolR

       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 3];
       #"EPICSConnErr" := #MyBoolsinWord[8];    //EPICSName: EPICSConnErr
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_HVPf_Doors"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "CloseR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CloseR
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_HVPf_Doors
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //#############################  ISRC HVPf Doors Status ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"CloseR";    //EPICSName: CloseR
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_HVPf_Res"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "CloseR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CloseR
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_HVPf_Res
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  HVPf Neutral To Ground Resistor Switches  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"CloseR";    //EPICSName: CloseR
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_INTF_DIAG"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "CPU_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CPU_Connected
      "DI1_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DI1_Connected
      "DI2_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DI2_Connected
      "AI1_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: AI1_Connected
      "AI2_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: AI2_Connected
      "DO1_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DO1_Connected
      "DO2_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DO2_Connected
      "CPU_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CPU_Status
      "DI1_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DI1_Status
      "DI2_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DI2_Status
      "AI1_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: AI1_Status
      "AI2_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: AI2_Status
      "DO1_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DO1_Status
      "DO2_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DO2_Status
      "RIO_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO_Connected
      "RIO_DI1_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO_DI1_Connected
      "RIO_DI2_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO_DI2_Connected
      "RIO_AI1_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO_AI1_Connected
      "RIO_DO1_Connected" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO_DO1_Connected
      "RIO_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO_Status
      "RIO_DI1_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO_DI1_Status
      "RIO_DI2_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO_DI2_Status
      "RIO_AI1_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO_AI1_Status
      "RIO_DO1_Status" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RIO_DO1_Status
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_INTF_DIAG
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC PLC Diagnostics  ##############################
       //###########################
       //STATUS BLOCK
       //###########################
       //Local modules connection state

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"CPU_Connected";    //EPICSName: CPU_Connected
       #MyBoolsinWord[9] := #"DI1_Connected";    //EPICSName: DI1_Connected
       #MyBoolsinWord[10] := #"DI2_Connected";    //EPICSName: DI2_Connected
       #MyBoolsinWord[11] := #"AI1_Connected";    //EPICSName: AI1_Connected
       #MyBoolsinWord[12] := #"AI2_Connected";    //EPICSName: AI2_Connected
       #MyBoolsinWord[13] := #"DO1_Connected";    //EPICSName: DO1_Connected
       #MyBoolsinWord[14] := #"DO2_Connected";    //EPICSName: DO2_Connected
       #MyBoolsinWord[15] := #"CPU_Status";    //EPICSName: CPU_Status
       #MyBoolsinWord[0] := #"DI1_Status";    //EPICSName: DI1_Status
       #MyBoolsinWord[1] := #"DI2_Status";    //EPICSName: DI2_Status
       #MyBoolsinWord[2] := #"AI1_Status";    //EPICSName: AI1_Status
       #MyBoolsinWord[3] := #"AI2_Status";    //EPICSName: AI2_Status
       #MyBoolsinWord[4] := #"DO1_Status";    //EPICSName: DO1_Status
       #MyBoolsinWord[5] := #"DO2_Status";    //EPICSName: DO2_Status
       #MyBoolsinWord[6] := #"RIO_Connected";    //EPICSName: RIO_Connected
       #MyBoolsinWord[7] := #"RIO_DI1_Connected";    //EPICSName: RIO_DI1_Connected
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"RIO_DI2_Connected";    //EPICSName: RIO_DI2_Connected
       #MyBoolsinWord[9] := #"RIO_AI1_Connected";    //EPICSName: RIO_AI1_Connected
       #MyBoolsinWord[10] := #"RIO_DO1_Connected";    //EPICSName: RIO_DO1_Connected
       #MyBoolsinWord[11] := #"RIO_Status";    //EPICSName: RIO_Status
       #MyBoolsinWord[12] := #"RIO_DI1_Status";    //EPICSName: RIO_DI1_Status
       #MyBoolsinWord[13] := #"RIO_DI2_Status";    //EPICSName: RIO_DI2_Status
       #MyBoolsinWord[14] := #"RIO_AI1_Status";    //EPICSName: RIO_AI1_Status
       #MyBoolsinWord[15] := #"RIO_DO1_Status";    //EPICSName: RIO_DO1_Status
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_INTF_DPL"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "DPLOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DPLOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_INTF_DPL
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT interface with DPL  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"DPLOK";    //EPICSName: DPLOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_INTF_EMU"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "EMUOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EMUOK
      "EMUOK_Magtr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EMUOK_Magtr
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_INTF_EMU
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT interface with EMU  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"EMUOK";    //EPICSName: EMUOK
       #MyBoolsinWord[9] := #"EMUOK_Magtr";    //EPICSName: EMUOK_Magtr
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_INTF_HMI"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "ComIocOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ComIocOK
      "ComRioOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ComRioOK
      "ISrcOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ISrcOK
      "EVENT_A_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EVENT_A_MEMO
      "EVENT_B_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EVENT_B_MEMO
      "EVENT_C_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EVENT_C_MEMO
      "EVENT_D_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EVENT_D_MEMO
      "EVENT_E_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EVENT_E_MEMO
      "EVENT_F_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EVENT_F_MEMO
      "EVENT_G_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EVENT_G_MEMO
      "EVENT_H_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EVENT_H_MEMO
      "ChopPwrSysOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ChopPwrSysOK_MEMO
      "ChopVoltAlarm_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ChopVoltAlarm_MEMO
      "ChopWtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ChopWtrFlowOK_MEMO
      "Sol1WtrTempOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Sol1WtrTempOK_MEMO
      "Sol2WtrTempOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Sol2WtrTempOK_MEMO
      "Sol1WtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Sol1WtrFlowOK_MEMO
      "Sol2WtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Sol2WtrFlowOK_MEMO
      "Sol1CurMaxErr_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Sol1CurMaxErr_MEMO
      "Sol2CurMaxErr_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Sol2CurMaxErr_MEMO
      "Str1HCurMaxErr_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Str1HCurMaxErr_MEMO
      "Str2HCurMaxErr_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Str2HCurMaxErr_MEMO
      "Str1VCurMaxErr_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Str1VCurMaxErr_MEMO
      "Str2VCurMaxErr_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Str2VCurMaxErr_MEMO
      "Coil1PwrSuppOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Coil1PwrSuppOK_MEMO
      "Coil2PwrSuppOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Coil2PwrSuppOK_MEMO
      "Coil3PwrSuppOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Coil3PwrSuppOK_MEMO
      "HVITLidOpenR_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVITLidOpenR_MEMO
      "HVITOilTempOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVITOilTempOK_MEMO
      "GndWtrTempMaxErr_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: GndWtrTempMaxErr_MEMO
      "HVWtrTempMaxErr_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVWtrTempMaxErr_MEMO
      "RepWtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: RepWtrFlowOK_MEMO
      "IrisWtrTemp1Err_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: IrisWtrTemp1Err_MEMO
      "IrisWtrTemp2Err_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: IrisWtrTemp2Err_MEMO
      "IrisWtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: IrisWtrFlowOK_MEMO
      "EMUHWtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EMUHWtrFlowOK_MEMO
      "EMUVWtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EMUVWtrFlowOK_MEMO
      "FCWtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: FCWtrFlowOK_MEMO
      "EMUOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EMUOK_MEMO
      "IBSWtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: IBSWtrFlowOK_MEMO
      "CollWtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CollWtrFlowOK_MEMO
      "MatTrWtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: MatTrWtrFlowOK_MEMO
      "PlasChWtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: PlasChWtrFlowOK_MEMO
      "VacOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: VacOK_MEMO
      "VacPermit_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: VacPermit_MEMO
      "ComRioOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ComRioOK_MEMO
      "MPSOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: MPSOK_MEMO
      "HVPSVolOK_Magtr_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVPSVolOK_Magtr_MEMO
      "DPLOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: DPLOK_MEMO
      "HVPfDoors_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVPfDoors_MEMO
      "HVPfRes_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVPfRes_MEMO
      "HVPermit_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVPermit_MEMO
      "ComIocOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ComIocOK_MEMO
      "Rep1VolOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Rep1VolOK_MEMO
      "Rep2VolOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Rep2VolOK_MEMO
      "MagPulseModeOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: MagPulseModeOK_MEMO
      "ESTOP_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ESTOP_MEMO
      "HVPSConnErr_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVPSConnErr_MEMO
      "Coil1WtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Coil1WtrFlowOK_MEMO
      "Coil2WtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Coil2WtrFlowOK_MEMO
      "Coil3WtrFlowOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Coil3WtrFlowOK_MEMO
      "Coil1WtrTempOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Coil1WtrTempOK_MEMO
      "Coil2WtrTempOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Coil2WtrTempOK_MEMO
      "Coil3WtrTempOK_MEMO" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: Coil3WtrTempOK_MEMO
      "F_MagtrEnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_MagtrEnCmd
      "F_ChopWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_ChopWtrFlowOK
      "F_ChopPwrSysOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_ChopPwrSysOK
      "F_ChopVoltAlarm" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_ChopVoltAlarm
      "F_Sol1WtrTempOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Sol1WtrTempOK
      "F_Sol2WtrTempOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Sol2WtrTempOK
      "F_Sol1WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Sol1WtrFlowOK
      "F_Sol2WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Sol2WtrFlowOK
      "F_Sol1CurMaxErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Sol1CurMaxErr
      "F_Sol2CurMaxErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Sol2CurMaxErr
      "F_Str1HCurMaxErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Str1HCurMaxErr
      "F_Str2HCurMaxErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Str2HCurMaxErr
      "F_Str1VCurMaxErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Str1VCurMaxErr
      "F_Str2VCurMaxErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Str2VCurMaxErr
      "F_Coil1WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil1WtrFlowOK
      "F_Coil2WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil2WtrFlowOK
      "F_Coil3WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil3WtrFlowOK
      "F_Coil1WtrTempOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil1WtrTempOK
      "F_Coil2WtrTempOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil2WtrTempOK
      "F_Coil3WtrTempOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil3WtrTempOK
      "F_Coil1PwrSuppOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil1PwrSuppOK
      "F_Coil2PwrSuppOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil2PwrSuppOK
      "F_Coil3PwrSuppOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil3PwrSuppOK
      "F_HVITLidOpen" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_HVITLidOpen
      "F_HVITOilTempOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_HVITOilTempOK
      "F_GndWtrTempMaxErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_GndWtrTempMaxErr
      "F_HVWtrTempMaxErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_HVWtrTempMaxErr
      "F_RepWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_RepWtrFlowOK
      "F_Rep1VolOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Rep1VolOK
      "F_Rep2VolOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Rep2VolOK
      "F_IrisWtrTemp1Err" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_IrisWtrTemp1Err
      "F_IrisWtrTemp2Err" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_IrisWtrTemp2Err
      "F_IrisWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_IrisWtrFlowOK
      "F_FCWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_FCWtrFlowOK
      "F_EMUHWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_EMUHWtrFlowOK
      "F_EMUVWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_EMUVWtrFlowOK
      "F_EMUOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_EMUOK
      "F_IBSWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_IBSWtrFlowOK
      "F_CollWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_CollWtrFlowOK
      "F_MatTrWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_MatTrWtrFlowOK
      "F_PlasChWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_PlasChWtrFlowOK
      "F_ComRioOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_ComRioOK
      "F_MPSOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_MPSOK
      "F_VacOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_VacOK
      "F_VacPermit" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_VacPermit
      "F_HVPSVolOK_Magtr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_HVPSVolOK_Magtr
      "F_MagPulseModeOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_MagPulseModeOK
      "F_DPLOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_DPLOK
      "F_HVITLckEnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_HVITLckEnCmd
      "F_HVPfDoors" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_HVPfDoors
      "F_HVPfRes" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_HVPfRes
      "F_HVPermit" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_HVPermit
      "F_ComIocOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_ComIocOK
      "F_Coil1EnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil1EnCmd
      "F_Coil2EnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil2EnCmd
      "F_Coil3EnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Coil3EnCmd
      "F_Sol1EnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Sol1EnCmd
      "F_Str1HEnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Str1HEnCmd
      "F_Str1VEnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Str1VEnCmd
      "F_Sol2EnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Sol2EnCmd
      "F_Str2HEnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Str2HEnCmd
      "F_Str2VEnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_Str2VEnCmd
      "F_VacVVAOpenCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_VacVVAOpenCmd
      "F_ChopHVEnCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_ChopHVEnCmd
      "F_ISrcOKtoMPS" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_ISrcOKtoMPS
      "F_MWPowerOn" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_MWPowerOn
      "F_VacVEVMCOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_VacVEVMCOK
      "F_GNDInletPres" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_GNDInletPres
      "F_GNDOutletPres" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: F_GNDOutletPres
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "EVENT_A_ACK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: EVENT_A_ACK
      "EVENT_B_ACK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: EVENT_B_ACK
      "EVENT_C_ACK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: EVENT_C_ACK
      "EVENT_D_ACK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: EVENT_D_ACK
      "EVENT_E_ACK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: EVENT_E_ACK
      "EVENT_F_ACK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: EVENT_F_ACK
      "EVENT_G_ACK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: EVENT_G_ACK
      "EVENT_H_ACK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: EVENT_H_ACK
      "VacLevelMaxS" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: VacLevelMaxS
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_INTF_HMI
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT HMI  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"ComIocOK";    //EPICSName: ComIocOK
       #MyBoolsinWord[9] := #"ComRioOK";    //EPICSName: ComRioOK
       #MyBoolsinWord[10] := #"ISrcOK";    //EPICSName: ISrcOK
       #MyBoolsinWord[11] := #"EVENT_A_MEMO";    //EPICSName: EVENT_A_MEMO
       #MyBoolsinWord[12] := #"EVENT_B_MEMO";    //EPICSName: EVENT_B_MEMO
       #MyBoolsinWord[13] := #"EVENT_C_MEMO";    //EPICSName: EVENT_C_MEMO
       #MyBoolsinWord[14] := #"EVENT_D_MEMO";    //EPICSName: EVENT_D_MEMO
       #MyBoolsinWord[15] := #"EVENT_E_MEMO";    //EPICSName: EVENT_E_MEMO
       #MyBoolsinWord[0] := #"EVENT_F_MEMO";    //EPICSName: EVENT_F_MEMO
       #MyBoolsinWord[1] := #"EVENT_G_MEMO";    //EPICSName: EVENT_G_MEMO
       #MyBoolsinWord[2] := #"EVENT_H_MEMO";    //EPICSName: EVENT_H_MEMO
       #MyBoolsinWord[3] := #"ChopPwrSysOK_MEMO";    //EPICSName: ChopPwrSysOK_MEMO
       #MyBoolsinWord[4] := #"ChopVoltAlarm_MEMO";    //EPICSName: ChopVoltAlarm_MEMO
       #MyBoolsinWord[5] := #"ChopWtrFlowOK_MEMO";    //EPICSName: ChopWtrFlowOK_MEMO
       #MyBoolsinWord[6] := #"Sol1WtrTempOK_MEMO";    //EPICSName: Sol1WtrTempOK_MEMO
       #MyBoolsinWord[7] := #"Sol2WtrTempOK_MEMO";    //EPICSName: Sol2WtrTempOK_MEMO
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"Sol1WtrFlowOK_MEMO";    //EPICSName: Sol1WtrFlowOK_MEMO
       #MyBoolsinWord[9] := #"Sol2WtrFlowOK_MEMO";    //EPICSName: Sol2WtrFlowOK_MEMO
       #MyBoolsinWord[10] := #"Sol1CurMaxErr_MEMO";    //EPICSName: Sol1CurMaxErr_MEMO
       #MyBoolsinWord[11] := #"Sol2CurMaxErr_MEMO";    //EPICSName: Sol2CurMaxErr_MEMO
       #MyBoolsinWord[12] := #"Str1HCurMaxErr_MEMO";    //EPICSName: Str1HCurMaxErr_MEMO
       #MyBoolsinWord[13] := #"Str2HCurMaxErr_MEMO";    //EPICSName: Str2HCurMaxErr_MEMO
       #MyBoolsinWord[14] := #"Str1VCurMaxErr_MEMO";    //EPICSName: Str1VCurMaxErr_MEMO
       #MyBoolsinWord[15] := #"Str2VCurMaxErr_MEMO";    //EPICSName: Str2VCurMaxErr_MEMO
       #MyBoolsinWord[0] := #"Coil1PwrSuppOK_MEMO";    //EPICSName: Coil1PwrSuppOK_MEMO
       #MyBoolsinWord[1] := #"Coil2PwrSuppOK_MEMO";    //EPICSName: Coil2PwrSuppOK_MEMO
       #MyBoolsinWord[2] := #"Coil3PwrSuppOK_MEMO";    //EPICSName: Coil3PwrSuppOK_MEMO
       #MyBoolsinWord[3] := #"HVITLidOpenR_MEMO";    //EPICSName: HVITLidOpenR_MEMO
       #MyBoolsinWord[4] := #"HVITOilTempOK_MEMO";    //EPICSName: HVITOilTempOK_MEMO
       #MyBoolsinWord[5] := #"GndWtrTempMaxErr_MEMO";    //EPICSName: GndWtrTempMaxErr_MEMO
       #MyBoolsinWord[6] := #"HVWtrTempMaxErr_MEMO";    //EPICSName: HVWtrTempMaxErr_MEMO
       #MyBoolsinWord[7] := #"RepWtrFlowOK_MEMO";    //EPICSName: RepWtrFlowOK_MEMO
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"IrisWtrTemp1Err_MEMO";    //EPICSName: IrisWtrTemp1Err_MEMO
       #MyBoolsinWord[9] := #"IrisWtrTemp2Err_MEMO";    //EPICSName: IrisWtrTemp2Err_MEMO
       #MyBoolsinWord[10] := #"IrisWtrFlowOK_MEMO";    //EPICSName: IrisWtrFlowOK_MEMO
       #MyBoolsinWord[11] := #"EMUHWtrFlowOK_MEMO";    //EPICSName: EMUHWtrFlowOK_MEMO
       #MyBoolsinWord[12] := #"EMUVWtrFlowOK_MEMO";    //EPICSName: EMUVWtrFlowOK_MEMO
       #MyBoolsinWord[13] := #"FCWtrFlowOK_MEMO";    //EPICSName: FCWtrFlowOK_MEMO
       #MyBoolsinWord[14] := #"EMUOK_MEMO";    //EPICSName: EMUOK_MEMO
       #MyBoolsinWord[15] := #"IBSWtrFlowOK_MEMO";    //EPICSName: IBSWtrFlowOK_MEMO
       #MyBoolsinWord[0] := #"CollWtrFlowOK_MEMO";    //EPICSName: CollWtrFlowOK_MEMO
       #MyBoolsinWord[1] := #"MatTrWtrFlowOK_MEMO";    //EPICSName: MatTrWtrFlowOK_MEMO
       #MyBoolsinWord[2] := #"PlasChWtrFlowOK_MEMO";    //EPICSName: PlasChWtrFlowOK_MEMO
       #MyBoolsinWord[3] := #"VacOK_MEMO";    //EPICSName: VacOK_MEMO
       #MyBoolsinWord[4] := #"VacPermit_MEMO";    //EPICSName: VacPermit_MEMO
       #MyBoolsinWord[5] := #"ComRioOK_MEMO";    //EPICSName: ComRioOK_MEMO
       #MyBoolsinWord[6] := #"MPSOK_MEMO";    //EPICSName: MPSOK_MEMO
       #MyBoolsinWord[7] := #"HVPSVolOK_Magtr_MEMO";    //EPICSName: HVPSVolOK_Magtr_MEMO
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"DPLOK_MEMO";    //EPICSName: DPLOK_MEMO
       #MyBoolsinWord[9] := #"HVPfDoors_MEMO";    //EPICSName: HVPfDoors_MEMO
       #MyBoolsinWord[10] := #"HVPfRes_MEMO";    //EPICSName: HVPfRes_MEMO
       #MyBoolsinWord[11] := #"HVPermit_MEMO";    //EPICSName: HVPermit_MEMO
       #MyBoolsinWord[12] := #"ComIocOK_MEMO";    //EPICSName: ComIocOK_MEMO
       #MyBoolsinWord[13] := #"Rep1VolOK_MEMO";    //EPICSName: Rep1VolOK_MEMO
       #MyBoolsinWord[14] := #"Rep2VolOK_MEMO";    //EPICSName: Rep2VolOK_MEMO
       #MyBoolsinWord[15] := #"MagPulseModeOK_MEMO";    //EPICSName: MagPulseModeOK_MEMO
       #MyBoolsinWord[0] := #"ESTOP_MEMO";    //EPICSName: ESTOP_MEMO
       #MyBoolsinWord[1] := #"HVPSConnErr_MEMO";    //EPICSName: HVPSConnErr_MEMO
       #MyBoolsinWord[2] := #"Coil1WtrFlowOK_MEMO";    //EPICSName: Coil1WtrFlowOK_MEMO
       #MyBoolsinWord[3] := #"Coil2WtrFlowOK_MEMO";    //EPICSName: Coil2WtrFlowOK_MEMO
       #MyBoolsinWord[4] := #"Coil3WtrFlowOK_MEMO";    //EPICSName: Coil3WtrFlowOK_MEMO
       #MyBoolsinWord[5] := #"Coil1WtrTempOK_MEMO";    //EPICSName: Coil1WtrTempOK_MEMO
       #MyBoolsinWord[6] := #"Coil2WtrTempOK_MEMO";    //EPICSName: Coil2WtrTempOK_MEMO
       #MyBoolsinWord[7] := #"Coil3WtrTempOK_MEMO";    //EPICSName: Coil3WtrTempOK_MEMO
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 3] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"F_MagtrEnCmd";    //EPICSName: F_MagtrEnCmd
       #MyBoolsinWord[9] := #"F_ChopWtrFlowOK";    //EPICSName: F_ChopWtrFlowOK
       #MyBoolsinWord[10] := #"F_ChopPwrSysOK";    //EPICSName: F_ChopPwrSysOK
       #MyBoolsinWord[11] := #"F_ChopVoltAlarm";    //EPICSName: F_ChopVoltAlarm
       #MyBoolsinWord[12] := #"F_Sol1WtrTempOK";    //EPICSName: F_Sol1WtrTempOK
       #MyBoolsinWord[13] := #"F_Sol2WtrTempOK";    //EPICSName: F_Sol2WtrTempOK
       #MyBoolsinWord[14] := #"F_Sol1WtrFlowOK";    //EPICSName: F_Sol1WtrFlowOK
       #MyBoolsinWord[15] := #"F_Sol2WtrFlowOK";    //EPICSName: F_Sol2WtrFlowOK
       #MyBoolsinWord[0] := #"F_Sol1CurMaxErr";    //EPICSName: F_Sol1CurMaxErr
       #MyBoolsinWord[1] := #"F_Sol2CurMaxErr";    //EPICSName: F_Sol2CurMaxErr
       #MyBoolsinWord[2] := #"F_Str1HCurMaxErr";    //EPICSName: F_Str1HCurMaxErr
       #MyBoolsinWord[3] := #"F_Str2HCurMaxErr";    //EPICSName: F_Str2HCurMaxErr
       #MyBoolsinWord[4] := #"F_Str1VCurMaxErr";    //EPICSName: F_Str1VCurMaxErr
       #MyBoolsinWord[5] := #"F_Str2VCurMaxErr";    //EPICSName: F_Str2VCurMaxErr
       #MyBoolsinWord[6] := #"F_Coil1WtrFlowOK";    //EPICSName: F_Coil1WtrFlowOK
       #MyBoolsinWord[7] := #"F_Coil2WtrFlowOK";    //EPICSName: F_Coil2WtrFlowOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 4] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"F_Coil3WtrFlowOK";    //EPICSName: F_Coil3WtrFlowOK
       #MyBoolsinWord[9] := #"F_Coil1WtrTempOK";    //EPICSName: F_Coil1WtrTempOK
       #MyBoolsinWord[10] := #"F_Coil2WtrTempOK";    //EPICSName: F_Coil2WtrTempOK
       #MyBoolsinWord[11] := #"F_Coil3WtrTempOK";    //EPICSName: F_Coil3WtrTempOK
       #MyBoolsinWord[12] := #"F_Coil1PwrSuppOK";    //EPICSName: F_Coil1PwrSuppOK
       #MyBoolsinWord[13] := #"F_Coil2PwrSuppOK";    //EPICSName: F_Coil2PwrSuppOK
       #MyBoolsinWord[14] := #"F_Coil3PwrSuppOK";    //EPICSName: F_Coil3PwrSuppOK
       #MyBoolsinWord[15] := #"F_HVITLidOpen";    //EPICSName: F_HVITLidOpen
       #MyBoolsinWord[0] := #"F_HVITOilTempOK";    //EPICSName: F_HVITOilTempOK
       #MyBoolsinWord[1] := #"F_GndWtrTempMaxErr";    //EPICSName: F_GndWtrTempMaxErr
       #MyBoolsinWord[2] := #"F_HVWtrTempMaxErr";    //EPICSName: F_HVWtrTempMaxErr
       #MyBoolsinWord[3] := #"F_RepWtrFlowOK";    //EPICSName: F_RepWtrFlowOK
       #MyBoolsinWord[4] := #"F_Rep1VolOK";    //EPICSName: F_Rep1VolOK
       #MyBoolsinWord[5] := #"F_Rep2VolOK";    //EPICSName: F_Rep2VolOK
       #MyBoolsinWord[6] := #"F_IrisWtrTemp1Err";    //EPICSName: F_IrisWtrTemp1Err
       #MyBoolsinWord[7] := #"F_IrisWtrTemp2Err";    //EPICSName: F_IrisWtrTemp2Err
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 5] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"F_IrisWtrFlowOK";    //EPICSName: F_IrisWtrFlowOK
       #MyBoolsinWord[9] := #"F_FCWtrFlowOK";    //EPICSName: F_FCWtrFlowOK
       #MyBoolsinWord[10] := #"F_EMUHWtrFlowOK";    //EPICSName: F_EMUHWtrFlowOK
       #MyBoolsinWord[11] := #"F_EMUVWtrFlowOK";    //EPICSName: F_EMUVWtrFlowOK
       #MyBoolsinWord[12] := #"F_EMUOK";    //EPICSName: F_EMUOK
       #MyBoolsinWord[13] := #"F_IBSWtrFlowOK";    //EPICSName: F_IBSWtrFlowOK
       #MyBoolsinWord[14] := #"F_CollWtrFlowOK";    //EPICSName: F_CollWtrFlowOK
       #MyBoolsinWord[15] := #"F_MatTrWtrFlowOK";    //EPICSName: F_MatTrWtrFlowOK
       #MyBoolsinWord[0] := #"F_PlasChWtrFlowOK";    //EPICSName: F_PlasChWtrFlowOK
       #MyBoolsinWord[1] := #"F_ComRioOK";    //EPICSName: F_ComRioOK
       #MyBoolsinWord[2] := #"F_MPSOK";    //EPICSName: F_MPSOK
       #MyBoolsinWord[3] := #"F_VacOK";    //EPICSName: F_VacOK
       #MyBoolsinWord[4] := #"F_VacPermit";    //EPICSName: F_VacPermit
       #MyBoolsinWord[5] := #"F_HVPSVolOK_Magtr";    //EPICSName: F_HVPSVolOK_Magtr
       #MyBoolsinWord[6] := #"F_MagPulseModeOK";    //EPICSName: F_MagPulseModeOK
       #MyBoolsinWord[7] := #"F_DPLOK";    //EPICSName: F_DPLOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 6] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"F_HVITLckEnCmd";    //EPICSName: F_HVITLckEnCmd
       #MyBoolsinWord[9] := #"F_HVPfDoors";    //EPICSName: F_HVPfDoors
       #MyBoolsinWord[10] := #"F_HVPfRes";    //EPICSName: F_HVPfRes
       #MyBoolsinWord[11] := #"F_HVPermit";    //EPICSName: F_HVPermit
       #MyBoolsinWord[12] := #"F_ComIocOK";    //EPICSName: F_ComIocOK
       #MyBoolsinWord[13] := #"F_Coil1EnCmd";    //EPICSName: F_Coil1EnCmd
       #MyBoolsinWord[14] := #"F_Coil2EnCmd";    //EPICSName: F_Coil2EnCmd
       #MyBoolsinWord[15] := #"F_Coil3EnCmd";    //EPICSName: F_Coil3EnCmd
       #MyBoolsinWord[0] := #"F_Sol1EnCmd";    //EPICSName: F_Sol1EnCmd
       #MyBoolsinWord[1] := #"F_Str1HEnCmd";    //EPICSName: F_Str1HEnCmd
       #MyBoolsinWord[2] := #"F_Str1VEnCmd";    //EPICSName: F_Str1VEnCmd
       #MyBoolsinWord[3] := #"F_Sol2EnCmd";    //EPICSName: F_Sol2EnCmd
       #MyBoolsinWord[4] := #"F_Str2HEnCmd";    //EPICSName: F_Str2HEnCmd
       #MyBoolsinWord[5] := #"F_Str2VEnCmd";    //EPICSName: F_Str2VEnCmd
       #MyBoolsinWord[6] := #"F_VacVVAOpenCmd";    //EPICSName: F_VacVVAOpenCmd
       #MyBoolsinWord[7] := #"F_ChopHVEnCmd";    //EPICSName: F_ChopHVEnCmd
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 7] := #MyWord;

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"F_ISrcOKtoMPS";    //EPICSName: F_ISrcOKtoMPS
       #MyBoolsinWord[9] := #"F_MWPowerOn";    //EPICSName: F_MWPowerOn
       #MyBoolsinWord[10] := #"F_VacVEVMCOK";    //EPICSName: F_VacVEVMCOK
       #MyBoolsinWord[11] := #"F_GNDInletPres";    //EPICSName: F_GNDInletPres
       #MyBoolsinWord[12] := #"F_GNDOutletPres";    //EPICSName: F_GNDOutletPres
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 8] := #MyWord;

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       IF (NOT "Utilities".TestInProgress) THEN
       	"EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       END_IF;
       #"EVENT_A_ACK" := #MyBoolsinWord[8];    //EPICSName: EVENT_A_ACK
       #"EVENT_B_ACK" := #MyBoolsinWord[9];    //EPICSName: EVENT_B_ACK
       #"EVENT_C_ACK" := #MyBoolsinWord[10];    //EPICSName: EVENT_C_ACK
       #"EVENT_D_ACK" := #MyBoolsinWord[11];    //EPICSName: EVENT_D_ACK
       #"EVENT_E_ACK" := #MyBoolsinWord[12];    //EPICSName: EVENT_E_ACK
       #"EVENT_F_ACK" := #MyBoolsinWord[13];    //EPICSName: EVENT_F_ACK
       #"EVENT_G_ACK" := #MyBoolsinWord[14];    //EPICSName: EVENT_G_ACK
       #"EVENT_H_ACK" := #MyBoolsinWord[15];    //EPICSName: EVENT_H_ACK

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 2];
       #"VacLevelMaxS" := #MyReal;    //EPICSName: VacLevelMaxS
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_INTF_MPS"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "MPSOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: MPSOK
      "ISrcOKtoMPS" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: ISrcOKtoMPS
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_INTF_MPS
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT interface with MPS  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"MPSOK";    //EPICSName: MPSOK
       #MyBoolsinWord[9] := #"ISrcOKtoMPS";    //EPICSName: ISrcOKtoMPS
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_INTF_PSS"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "PSSOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: PSSOK
      "HVPermitR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HVPermitR
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_INTF_PSS
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT interface with PSS  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"PSSOK";    //EPICSName: PSSOK
       #MyBoolsinWord[9] := #"HVPermitR";    //EPICSName: HVPermitR
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_INTF_VAC"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "VacOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: VacOK
      "VacPermit" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: VacPermit
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_INTF_VAC
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT interface with Vacuum System  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"VacOK";    //EPICSName: VacOK
       #MyBoolsinWord[9] := #"VacPermit";    //EPICSName: VacPermit
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_IRIS"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrFlowOK
      "WtrTempMax1Err" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrTempMax1Err
      "WtrTempMax2Err" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrTempMax2Err
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_IRIS
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  LEBT Iris  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"WtrFlowOK";    //EPICSName: WtrFlowOK
       #MyBoolsinWord[9] := #"WtrTempMax1Err";    //EPICSName: WtrTempMax1Err
       #MyBoolsinWord[10] := #"WtrTempMax2Err";    //EPICSName: WtrTempMax2Err
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_Magtr"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "EnCmdR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnCmdR
      "MWPowerOnR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: MWPowerOnR
      "PulseModeOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: PulseModeOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "iPulseMode" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Parameter variable: iPulseMode
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_Magtr
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC Magnetron  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"EnCmdR";    //EPICSName: EnCmdR
       #MyBoolsinWord[9] := #"MWPowerOnR";    //EPICSName: MWPowerOnR
       #MyBoolsinWord[10] := #"PulseModeOK";    //EPICSName: PulseModeOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       #"iPulseMode" := #MyBoolsinWord[8];    //EPICSName: iPulseMode
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_MatTr"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrFlowOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_MatTr
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT Matching Transformer  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"WtrFlowOK";    //EPICSName: WtrFlowOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_PBI_EMU"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "HorWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: HorWtrFlowOK
      "VerWtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: VerWtrFlowOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_PBI_EMU
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  LEBT EMU  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"HorWtrFlowOK";    //EPICSName: HorWtrFlowOK
       #MyBoolsinWord[9] := #"VerWtrFlowOK";    //EPICSName: VerWtrFlowOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_PBI_FC"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrFlowOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_PBI_FC
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  LEBT FaradayCup  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"WtrFlowOK";    //EPICSName: WtrFlowOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_PS_COIL"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "PwrSuppOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: PwrSuppOK
      "EnCmdR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnCmdR
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_PS_COIL
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT Coil Power Supply  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"PwrSuppOK";    //EPICSName: PwrSuppOK
       #MyBoolsinWord[9] := #"EnCmdR";    //EPICSName: EnCmdR
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_PS_REP"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "VolOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: VolOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "iVolR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Parameter variable: iVolR
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_PS_REP
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISrc and LEBT Repeller's Power Supply  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"VolOK";    //EPICSName: VolOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

    //********************************************
    //************PARAMETER VARIABLES*************
    //********************************************


       #MyReal	:= 0.0;
       #MyWordsinReal[0]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       #MyWordsinReal[1]	:= "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 1];
       #"iVolR" := #MyReal;    //EPICSName: iVolR
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_PS_SOL_STR"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "CurR-CT" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: CurR-CT
      "EnCmdR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: EnCmdR
      "CurMaxErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: CurMaxErr
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_PS_SOL_STR
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  LEBT Solenoids and Steerers PowerSupply  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyReal := #"CurR-CT";    //EPICSName: CurR-CT
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"EnCmdR";    //EPICSName: EnCmdR
       #MyBoolsinWord[9] := #"CurMaxErr";    //EPICSName: CurMaxErr
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_PlasCh"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrFlowOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_PlasCh
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC Plasma Chamber  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"WtrFlowOK";    //EPICSName: WtrFlowOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_REP"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "WtrFlowOK" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrFlowOK
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_REP
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISrc and LEBT Repeller  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"WtrFlowOK";    //EPICSName: WtrFlowOK
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_STR"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "PolR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: PolR
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "PolPosCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: PolPosCmd
      "PolNegCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: PolNegCmd
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_STR
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //#############################  LEBT Steerer  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"PolR";    //EPICSName: PolR
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       IF (NOT "Utilities".TestInProgress) THEN
       	"EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       END_IF;
       #"PolPosCmd" := #MyBoolsinWord[8];    //EPICSName: PolPosCmd
       #"PolNegCmd" := #MyBoolsinWord[9];    //EPICSName: PolNegCmd
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_VAC_VVA"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "OpenR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpenR
      "OpenCmdRB" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: OpenCmdRB
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      "OpenCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: OpenCmd
      "CloseCmd" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Command variable: CloseCmd
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_VAC_VVA
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT H2 valve in HV platform  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyWord := W#0;
       #MyBoolsinWord[8] := #"OpenR";    //EPICSName: OpenR
       #MyBoolsinWord[9] := #"OpenCmdRB";    //EPICSName: OpenCmdRB
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWord;

    //********************************************
    //*************COMMAND VARIABLES**************
    //********************************************


       #MyWord := "EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0];
       IF (NOT "Utilities".TestInProgress) THEN
       	"EPICSToPLC"."Word"[#EPICSToPLCDataBlockOffset + 0] := 0;
       END_IF;
       #"OpenCmd" := #MyBoolsinWord[8];    //EPICSName: OpenCmd
       #"CloseCmd" := #MyBoolsinWord[9];    //EPICSName: CloseCmd
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_WTRC_PRES"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "PresR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: PresR
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_WTRC_PRES
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT Water Cooling Pressure Transmitter  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyReal := #"PresR";    //EPICSName: PresR
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWordsinReal[1];
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK
FUNCTION_BLOCK "DEVTYPE_ISRC_LEBT_WTRC_TEMP"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
   VAR_INPUT
      "TempR" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : REAL;   //EPICS Status variable: TempR
      "WtrTempMaxErr" { ExternalAccessible := 'True'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : BOOL;   //EPICS Status variable: WtrTempMaxErr
   EPICSToPLCLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device command register array (in words)
   EPICSToPLCDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in EPICS->PLC comms block where this device data resides (in words)
   EPICSToPLCParametersStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // The border offset between the Command and the Parameter area
   PLCToEPICSLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Length of device status register array (in words)
   PLCToEPICSDataBlockOffset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;   // Offset in PLC->EPICS comms block where this device data resides (in words)
   END_VAR
   VAR_OUTPUT
      DEVICE_PARAM_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Bool;
   END_VAR
   VAR_IN_OUT
   END_VAR
   Var DB_SPECIFIC
      MyWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Word;
      MyBytesinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..1] of Byte;
      MyBoolsinWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyWord : Array[0..15] of Bool;
      MyDInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DInt;
      MyWordsinDint { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDInt : Array[0..1] of Word;
      MyReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Real;
      MyWordsinReal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyReal : Array[0..1] of Word;
      MyInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Int;
      MyWordinInt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyInt : Word;
      MyDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : DWord;
      MyWordsinDWord { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyDWord : Array[0..1] of Word;
      MyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Time;
      MyWordsinTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyTime : Array[0..1] of Word;
      MyString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : String[40];
      MyWordsinString { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } AT MyString : Array[0..20] of Word;
   END_VAR
   VAR_TEMP
      HashModbus : DInt;
      HashIFA : DInt;
      HashTIAMap : DInt;
      i : Int;
   END_VAR
    //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
    //This block was generated by PLCFactory, please don't change it MANUALLY!
    //Input File Name: ISrc-010_Ctrl-PLC-01-template-IFA-20191106135317.ifa
    //Generated: 20191106135317
    //According to HASH: 1347332123
    //Device type: ISRC_LEBT_WTRC_TEMP
    //Description: This function does the variable mapping for a device. All device-variable will be linked to an interface variable defined in this block.

    //********************************************
    //****************HASH check******************
    //********************************************


    #MyWordsinDint[0] := "EPICSToPLC"."Word"[0];
    #MyWordsinDint[1] := "EPICSToPLC"."Word"[1];
    #HashModbus := #MyDInt; //Hash from EPICS/ModbusTCP

    #HashIFA := 1347332123; //Hash from Interface Factory as a constant

    #MyWordsinDint[0] := "PLCToEPICS"."Word"[0];
    #MyWordsinDint[1] := "PLCToEPICS"."Word"[1];
    #HashTIAMap := #MyDInt; //Hash from PLCFactory TIA Map


    IF ((#HashIFA = #HashModbus) AND (#HashModbus = #HashTIAMap)) THEN //Check CRCs
        #DEVICE_PARAM_OK := TRUE;
       //###########################  ISRC_LEBT Water Cooling Temperature Transmitter  ##############################
       //###########################
       //STATUS BLOCK
       //###########################

    //********************************************
    //*************STATUS VARIABLES***************
    //********************************************


       #MyReal := #"TempR";    //EPICSName: TempR
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 0] := #MyWordsinReal[0];
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 1] := #MyWordsinReal[1];

       #MyWord := W#0;
       #MyBoolsinWord[8] := #"WtrTempMaxErr";    //EPICSName: WtrTempMaxErr
       "PLCToEPICS"."Word"[#PLCToEPICSDataBlockOffset + 2] := #MyWord;
    Else
       #DEVICE_PARAM_OK := FALSE; //Invalid Hash
    END_IF;
END_FUNCTION_BLOCK

DATA_BLOCK "DEV_LEBT-020:ID-IBS-001_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_BDump"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:BMD-Chop_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_CHOP"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Coil-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_COIL_SOLENOID"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Coil-02_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_COIL_SOLENOID"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Coil-03_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_COIL_SOLENOID"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:BMD-Sol-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_COIL_SOLENOID"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:BMD-Sol-02_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_COIL_SOLENOID"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:ID-Coll_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_COLL"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:PwrC-HVIT-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_HVIT"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-HVPS_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_HVPS"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-HVPf-Doors_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_HVPf_Doors"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-HVPf-Res_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_HVPf_Res"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Intf-DIAG_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_INTF_DIAG"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Intf-DPL_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_INTF_DPL"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Intf-EMU_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_INTF_EMU"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Intf-HMI_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_INTF_HMI"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Intf-MPS_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_INTF_MPS"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Intf-PSS_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_INTF_PSS"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Intf-Vac_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_INTF_VAC"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:ID-Iris_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_IRIS"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-Magtr_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_Magtr"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-MatTr_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_MatTr"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:PBI-EMU-001_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PBI_EMU"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:PBI-FC-001_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PBI_FC"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:PwrC-CoilPS-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_COIL"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:PwrC-CoilPS-02_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_COIL"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:PwrC-CoilPS-03_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_COIL"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:PwrC-RepPS-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_REP"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:PwrC-RepPS-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_REP"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:PwrC-PSCH-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_SOL_STR"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:PwrC-PSCH-02_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_SOL_STR"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:PwrC-PSCV-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_SOL_STR"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:PwrC-PSCV-02_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_SOL_STR"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:PwrC-SolPS-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_SOL_STR"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:PwrC-SolPS-02_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PS_SOL_STR"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:ISS-PlasCh_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_PlasCh"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:BMD-Rep-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_REP"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:BMD-CH-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_STR"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:BMD-CH-02_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_STR"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:BMD-CV-01_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_STR"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_LEBT-010:BMD-CV-02_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_STR"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:Vac-VVA-01100_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_VAC_VVA"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:WtrC-PT-001_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_WTRC_PRES"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:WtrC-PT-002_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_WTRC_PRES"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:WtrC-PT-011_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_WTRC_PRES"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:WtrC-PT-012_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_WTRC_PRES"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:WtrC-TT-001_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_WTRC_TEMP"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:WtrC-TT-011_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_WTRC_TEMP"
BEGIN
END_DATA_BLOCK


DATA_BLOCK "DEV_ISrc-010:WtrC-TT-012_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0
NON_RETAIN
"DEVTYPE_ISRC_LEBT_WTRC_TEMP"
BEGIN
END_DATA_BLOCK

FUNCTION "EPICS_device_calls" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 1.0

   VAR_TEMP
      "LEBT-020:ID-IBS-001" : Bool;   // HASH codes are OK
      "LEBT-010:BMD-Chop" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Coil-01" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Coil-02" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Coil-03" : Bool;   // HASH codes are OK
      "LEBT-010:BMD-Sol-01" : Bool;   // HASH codes are OK
      "LEBT-010:BMD-Sol-02" : Bool;   // HASH codes are OK
      "LEBT-010:ID-Coll" : Bool;   // HASH codes are OK
      "ISrc-010:PwrC-HVIT-01" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-HVPS" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-HVPf-Doors" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-HVPf-Res" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Intf-DIAG" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Intf-DPL" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Intf-EMU" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Intf-HMI" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Intf-MPS" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Intf-PSS" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Intf-Vac" : Bool;   // HASH codes are OK
      "LEBT-010:ID-Iris" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-Magtr" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-MatTr" : Bool;   // HASH codes are OK
      "LEBT-010:PBI-EMU-001" : Bool;   // HASH codes are OK
      "LEBT-010:PBI-FC-001" : Bool;   // HASH codes are OK
      "ISrc-010:PwrC-CoilPS-01" : Bool;   // HASH codes are OK
      "ISrc-010:PwrC-CoilPS-02" : Bool;   // HASH codes are OK
      "ISrc-010:PwrC-CoilPS-03" : Bool;   // HASH codes are OK
      "ISrc-010:PwrC-RepPS-01" : Bool;   // HASH codes are OK
      "LEBT-010:PwrC-RepPS-01" : Bool;   // HASH codes are OK
      "LEBT-010:PwrC-PSCH-01" : Bool;   // HASH codes are OK
      "LEBT-010:PwrC-PSCH-02" : Bool;   // HASH codes are OK
      "LEBT-010:PwrC-PSCV-01" : Bool;   // HASH codes are OK
      "LEBT-010:PwrC-PSCV-02" : Bool;   // HASH codes are OK
      "LEBT-010:PwrC-SolPS-01" : Bool;   // HASH codes are OK
      "LEBT-010:PwrC-SolPS-02" : Bool;   // HASH codes are OK
      "ISrc-010:ISS-PlasCh" : Bool;   // HASH codes are OK
      "ISrc-010:BMD-Rep-01" : Bool;   // HASH codes are OK
      "LEBT-010:BMD-CH-01" : Bool;   // HASH codes are OK
      "LEBT-010:BMD-CH-02" : Bool;   // HASH codes are OK
      "LEBT-010:BMD-CV-01" : Bool;   // HASH codes are OK
      "LEBT-010:BMD-CV-02" : Bool;   // HASH codes are OK
      "ISrc-010:Vac-VVA-01100" : Bool;   // HASH codes are OK
      "ISrc-010:WtrC-PT-001" : Bool;   // HASH codes are OK
      "ISrc-010:WtrC-PT-002" : Bool;   // HASH codes are OK
      "ISrc-010:WtrC-PT-011" : Bool;   // HASH codes are OK
      "ISrc-010:WtrC-PT-012" : Bool;   // HASH codes are OK
      "ISrc-010:WtrC-TT-001" : Bool;   // HASH codes are OK
      "ISrc-010:WtrC-TT-011" : Bool;   // HASH codes are OK
      "ISrc-010:WtrC-TT-012" : Bool;   // HASH codes are OK
   END_VAR

BEGIN
      //Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
      //This block was generated by PLCFactory
      //According to HASH:1347332123
      //Description: Description: This function calls the devices according to the corresponding device type

        //DO NOT Modify the following line!!!
        "Utilities".TestInProgress := FALSE;
        "Utilities".EPICS_Device_calls_precessed := TRUE;


        //********************************************
        // Device name: LEBT-020:ID-IBS-001
        // Device type: ISRC_LEBT_BDump
        //********************************************

      "DEV_LEBT-020:ID-IBS-001_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=0+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=0+10);

        //********************************************
        // Device name: LEBT-010:BMD-Chop
        // Device type: ISRC_LEBT_CHOP
        //********************************************

      "DEV_LEBT-010:BMD-Chop_iDB" (EPICSToPLCLength:=1,
      EPICSToPLCDataBlockOffset:=0+10,
      EPICSToPLCParametersStart:=1,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=1+10);

        //********************************************
        // Device name: ISrc-010:ISS-Coil-01
        // Device type: ISRC_LEBT_COIL_SOLENOID
        //********************************************

      "DEV_ISrc-010:ISS-Coil-01_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=1+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=2+10);

        //********************************************
        // Device name: ISrc-010:ISS-Coil-02
        // Device type: ISRC_LEBT_COIL_SOLENOID
        //********************************************

      "DEV_ISrc-010:ISS-Coil-02_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=1+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=3+10);

        //********************************************
        // Device name: ISrc-010:ISS-Coil-03
        // Device type: ISRC_LEBT_COIL_SOLENOID
        //********************************************

      "DEV_ISrc-010:ISS-Coil-03_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=1+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=4+10);

        //********************************************
        // Device name: LEBT-010:BMD-Sol-01
        // Device type: ISRC_LEBT_COIL_SOLENOID
        //********************************************

      "DEV_LEBT-010:BMD-Sol-01_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=1+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=5+10);

        //********************************************
        // Device name: LEBT-010:BMD-Sol-02
        // Device type: ISRC_LEBT_COIL_SOLENOID
        //********************************************

      "DEV_LEBT-010:BMD-Sol-02_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=1+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=6+10);

        //********************************************
        // Device name: LEBT-010:ID-Coll
        // Device type: ISRC_LEBT_COLL
        //********************************************

      "DEV_LEBT-010:ID-Coll_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=1+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=7+10);

        //********************************************
        // Device name: ISrc-010:PwrC-HVIT-01
        // Device type: ISRC_LEBT_HVIT
        //********************************************

      "DEV_ISrc-010:PwrC-HVIT-01_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=1+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=8+10);

        //********************************************
        // Device name: ISrc-010:ISS-HVPS
        // Device type: ISRC_LEBT_HVPS
        //********************************************

      "DEV_ISrc-010:ISS-HVPS_iDB" (EPICSToPLCLength:=4,
      EPICSToPLCDataBlockOffset:=1+10,
      EPICSToPLCParametersStart:=1,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=9+10);

        //********************************************
        // Device name: ISrc-010:ISS-HVPf-Doors
        // Device type: ISRC_LEBT_HVPf_Doors
        //********************************************

      "DEV_ISrc-010:ISS-HVPf-Doors_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=5+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=10+10);

        //********************************************
        // Device name: ISrc-010:ISS-HVPf-Res
        // Device type: ISRC_LEBT_HVPf_Res
        //********************************************

      "DEV_ISrc-010:ISS-HVPf-Res_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=5+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=11+10);

        //********************************************
        // Device name: ISrc-010:ISS-Intf-DIAG
        // Device type: ISRC_LEBT_INTF_DIAG
        //********************************************

      "DEV_ISrc-010:ISS-Intf-DIAG_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=5+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=2,
      PLCToEPICSDataBlockOffset:=12+10);

        //********************************************
        // Device name: ISrc-010:ISS-Intf-DPL
        // Device type: ISRC_LEBT_INTF_DPL
        //********************************************

      "DEV_ISrc-010:ISS-Intf-DPL_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=5+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=14+10);

        //********************************************
        // Device name: ISrc-010:ISS-Intf-EMU
        // Device type: ISRC_LEBT_INTF_EMU
        //********************************************

      "DEV_ISrc-010:ISS-Intf-EMU_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=5+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=15+10);

        //********************************************
        // Device name: ISrc-010:ISS-Intf-HMI
        // Device type: ISRC_LEBT_INTF_HMI
        //********************************************

      "DEV_ISrc-010:ISS-Intf-HMI_iDB" (EPICSToPLCLength:=3,
      EPICSToPLCDataBlockOffset:=5+10,
      EPICSToPLCParametersStart:=1,
      PLCToEPICSLength:=9,
      PLCToEPICSDataBlockOffset:=16+10);

        //********************************************
        // Device name: ISrc-010:ISS-Intf-MPS
        // Device type: ISRC_LEBT_INTF_MPS
        //********************************************

      "DEV_ISrc-010:ISS-Intf-MPS_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=8+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=25+10);

        //********************************************
        // Device name: ISrc-010:ISS-Intf-PSS
        // Device type: ISRC_LEBT_INTF_PSS
        //********************************************

      "DEV_ISrc-010:ISS-Intf-PSS_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=8+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=26+10);

        //********************************************
        // Device name: ISrc-010:ISS-Intf-Vac
        // Device type: ISRC_LEBT_INTF_VAC
        //********************************************

      "DEV_ISrc-010:ISS-Intf-Vac_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=8+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=27+10);

        //********************************************
        // Device name: LEBT-010:ID-Iris
        // Device type: ISRC_LEBT_IRIS
        //********************************************

      "DEV_LEBT-010:ID-Iris_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=8+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=28+10);

        //********************************************
        // Device name: ISrc-010:ISS-Magtr
        // Device type: ISRC_LEBT_Magtr
        //********************************************

      "DEV_ISrc-010:ISS-Magtr_iDB" (EPICSToPLCLength:=1,
      EPICSToPLCDataBlockOffset:=8+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=29+10);

        //********************************************
        // Device name: ISrc-010:ISS-MatTr
        // Device type: ISRC_LEBT_MatTr
        //********************************************

      "DEV_ISrc-010:ISS-MatTr_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=9+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=30+10);

        //********************************************
        // Device name: LEBT-010:PBI-EMU-001
        // Device type: ISRC_LEBT_PBI_EMU
        //********************************************

      "DEV_LEBT-010:PBI-EMU-001_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=9+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=31+10);

        //********************************************
        // Device name: LEBT-010:PBI-FC-001
        // Device type: ISRC_LEBT_PBI_FC
        //********************************************

      "DEV_LEBT-010:PBI-FC-001_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=9+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=32+10);

        //********************************************
        // Device name: ISrc-010:PwrC-CoilPS-01
        // Device type: ISRC_LEBT_PS_COIL
        //********************************************

      "DEV_ISrc-010:PwrC-CoilPS-01_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=9+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=33+10);

        //********************************************
        // Device name: ISrc-010:PwrC-CoilPS-02
        // Device type: ISRC_LEBT_PS_COIL
        //********************************************

      "DEV_ISrc-010:PwrC-CoilPS-02_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=9+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=34+10);

        //********************************************
        // Device name: ISrc-010:PwrC-CoilPS-03
        // Device type: ISRC_LEBT_PS_COIL
        //********************************************

      "DEV_ISrc-010:PwrC-CoilPS-03_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=9+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=35+10);

        //********************************************
        // Device name: ISrc-010:PwrC-RepPS-01
        // Device type: ISRC_LEBT_PS_REP
        //********************************************

      "DEV_ISrc-010:PwrC-RepPS-01_iDB" (EPICSToPLCLength:=2,
      EPICSToPLCDataBlockOffset:=9+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=36+10);

        //********************************************
        // Device name: LEBT-010:PwrC-RepPS-01
        // Device type: ISRC_LEBT_PS_REP
        //********************************************

      "DEV_LEBT-010:PwrC-RepPS-01_iDB" (EPICSToPLCLength:=2,
      EPICSToPLCDataBlockOffset:=11+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=37+10);

        //********************************************
        // Device name: LEBT-010:PwrC-PSCH-01
        // Device type: ISRC_LEBT_PS_SOL_STR
        //********************************************

      "DEV_LEBT-010:PwrC-PSCH-01_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=13+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=3,
      PLCToEPICSDataBlockOffset:=38+10);

        //********************************************
        // Device name: LEBT-010:PwrC-PSCH-02
        // Device type: ISRC_LEBT_PS_SOL_STR
        //********************************************

      "DEV_LEBT-010:PwrC-PSCH-02_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=13+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=3,
      PLCToEPICSDataBlockOffset:=41+10);

        //********************************************
        // Device name: LEBT-010:PwrC-PSCV-01
        // Device type: ISRC_LEBT_PS_SOL_STR
        //********************************************

      "DEV_LEBT-010:PwrC-PSCV-01_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=13+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=3,
      PLCToEPICSDataBlockOffset:=44+10);

        //********************************************
        // Device name: LEBT-010:PwrC-PSCV-02
        // Device type: ISRC_LEBT_PS_SOL_STR
        //********************************************

      "DEV_LEBT-010:PwrC-PSCV-02_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=13+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=3,
      PLCToEPICSDataBlockOffset:=47+10);

        //********************************************
        // Device name: LEBT-010:PwrC-SolPS-01
        // Device type: ISRC_LEBT_PS_SOL_STR
        //********************************************

      "DEV_LEBT-010:PwrC-SolPS-01_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=13+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=3,
      PLCToEPICSDataBlockOffset:=50+10);

        //********************************************
        // Device name: LEBT-010:PwrC-SolPS-02
        // Device type: ISRC_LEBT_PS_SOL_STR
        //********************************************

      "DEV_LEBT-010:PwrC-SolPS-02_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=13+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=3,
      PLCToEPICSDataBlockOffset:=53+10);

        //********************************************
        // Device name: ISrc-010:ISS-PlasCh
        // Device type: ISRC_LEBT_PlasCh
        //********************************************

      "DEV_ISrc-010:ISS-PlasCh_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=13+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=56+10);

        //********************************************
        // Device name: ISrc-010:BMD-Rep-01
        // Device type: ISRC_LEBT_REP
        //********************************************

      "DEV_ISrc-010:BMD-Rep-01_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=13+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=57+10);

        //********************************************
        // Device name: LEBT-010:BMD-CH-01
        // Device type: ISRC_LEBT_STR
        //********************************************

      "DEV_LEBT-010:BMD-CH-01_iDB" (EPICSToPLCLength:=1,
      EPICSToPLCDataBlockOffset:=13+10,
      EPICSToPLCParametersStart:=1,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=58+10);

        //********************************************
        // Device name: LEBT-010:BMD-CH-02
        // Device type: ISRC_LEBT_STR
        //********************************************

      "DEV_LEBT-010:BMD-CH-02_iDB" (EPICSToPLCLength:=1,
      EPICSToPLCDataBlockOffset:=14+10,
      EPICSToPLCParametersStart:=1,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=59+10);

        //********************************************
        // Device name: LEBT-010:BMD-CV-01
        // Device type: ISRC_LEBT_STR
        //********************************************

      "DEV_LEBT-010:BMD-CV-01_iDB" (EPICSToPLCLength:=1,
      EPICSToPLCDataBlockOffset:=15+10,
      EPICSToPLCParametersStart:=1,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=60+10);

        //********************************************
        // Device name: LEBT-010:BMD-CV-02
        // Device type: ISRC_LEBT_STR
        //********************************************

      "DEV_LEBT-010:BMD-CV-02_iDB" (EPICSToPLCLength:=1,
      EPICSToPLCDataBlockOffset:=16+10,
      EPICSToPLCParametersStart:=1,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=61+10);

        //********************************************
        // Device name: ISrc-010:Vac-VVA-01100
        // Device type: ISRC_LEBT_VAC_VVA
        //********************************************

      "DEV_ISrc-010:Vac-VVA-01100_iDB" (EPICSToPLCLength:=1,
      EPICSToPLCDataBlockOffset:=17+10,
      EPICSToPLCParametersStart:=1,
      PLCToEPICSLength:=1,
      PLCToEPICSDataBlockOffset:=62+10);

        //********************************************
        // Device name: ISrc-010:WtrC-PT-001
        // Device type: ISRC_LEBT_WTRC_PRES
        //********************************************

      "DEV_ISrc-010:WtrC-PT-001_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=18+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=2,
      PLCToEPICSDataBlockOffset:=63+10);

        //********************************************
        // Device name: ISrc-010:WtrC-PT-002
        // Device type: ISRC_LEBT_WTRC_PRES
        //********************************************

      "DEV_ISrc-010:WtrC-PT-002_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=18+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=2,
      PLCToEPICSDataBlockOffset:=65+10);

        //********************************************
        // Device name: ISrc-010:WtrC-PT-011
        // Device type: ISRC_LEBT_WTRC_PRES
        //********************************************

      "DEV_ISrc-010:WtrC-PT-011_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=18+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=2,
      PLCToEPICSDataBlockOffset:=67+10);

        //********************************************
        // Device name: ISrc-010:WtrC-PT-012
        // Device type: ISRC_LEBT_WTRC_PRES
        //********************************************

      "DEV_ISrc-010:WtrC-PT-012_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=18+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=2,
      PLCToEPICSDataBlockOffset:=69+10);

        //********************************************
        // Device name: ISrc-010:WtrC-TT-001
        // Device type: ISRC_LEBT_WTRC_TEMP
        //********************************************

      "DEV_ISrc-010:WtrC-TT-001_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=18+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=3,
      PLCToEPICSDataBlockOffset:=71+10);

        //********************************************
        // Device name: ISrc-010:WtrC-TT-011
        // Device type: ISRC_LEBT_WTRC_TEMP
        //********************************************

      "DEV_ISrc-010:WtrC-TT-011_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=18+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=3,
      PLCToEPICSDataBlockOffset:=74+10);

        //********************************************
        // Device name: ISrc-010:WtrC-TT-012
        // Device type: ISRC_LEBT_WTRC_TEMP
        //********************************************

      "DEV_ISrc-010:WtrC-TT-012_iDB" (EPICSToPLCLength:=0,
      EPICSToPLCDataBlockOffset:=18+10,
      EPICSToPLCParametersStart:=0,
      PLCToEPICSLength:=3,
      PLCToEPICSDataBlockOffset:=77+10);
END_FUNCTION
DATA_BLOCK "EPICS_DebuggerResult"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      EPICS_Debugger_Checksum : Array[0..7] of Byte;   // Current TIA Portal Software Hash including PLC logic (this is not the EPICS IOC Hash)
      EPICS_Debugger_UtilitiesCall : String;   // PLCFactory Utilities call status
      EPICS_Debugger_DeviceCalls : String;   // PLCFactory DeviceCalls status
      EPICS_Debugger_IOCHash : String;   // EPICS IOC Hash vs. PLCFactory Hash
      EPICS_Debugger_ModBusHeartBeat : String;   // EPICS IOC Modbus (IOC->PLC) communication status
      EPICS_Debugger_S7Connection : String;   // EPICS IOC S7 TCP (PLC->IOC) communication status
      EPICS_Debugger_EPICS_GeneralState : String;   // Main status of the EPICS IOC communication
      EPICS_S7Port : Int;   // Actual TCP port that has been opened by the PLC
      EPICS_ModbusPort : Int;   // Actual ModBusTCP port that has been opened by the PLC
      EPICS_PLC_EthernetInterface : UInt;   // The currently used HW Identifer of the Ethernet Port on the PLC dedicated to EPICS
   END_VAR

BEGIN

END_DATA_BLOCK
FUNCTION_BLOCK "EPICS_DebuggerFB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      GetChecksum_Instance {OriginalPartName := 'GetChecksum_FB_807_S71500'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : GetChecksum;
      execute { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      scope { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt := 1;
      busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      memErrStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      CheckUtilitiesTON {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      UtilSquareErrorTON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      CheckUtilitiesTON2 {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      UtilSquareErrorTON2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ModBus_TON {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      ModBus_wordsave { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
   END_VAR
   VAR DB_SPECIFIC
      Helper_String { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      Helper_String_Array { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT Helper_String : Struct
         String_Maximal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;
         String_Actual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;
         StringValueArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..15] of Byte;
      END_STRUCT;
   END_VAR
   VAR 
      S7ConnTON {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
   END_VAR

   VAR_TEMP 
      i : Int;
      ModBusOK : Bool;
      S7OK : Bool;
   END_VAR


BEGIN
	//Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
	//This block was generated by PLCFactory
	//Description: This FB checks the EPICS configuration and outputs the result into EPICS_DebuggerResult.
	
	//DO NOT Modify this block!!!
	
	
	#GetChecksum_Instance(Scope:=#scope,
	                      Done=>#done,
	                      Busy=>#busy,
	                      Error=>#error,
	                      Status=>#memErrStatus,
	                      Checksum:="EPICS_DebuggerResult".EPICS_Debugger_Checksum);
	
	
	#CheckUtilitiesTON(IN:="Utilities".Square_100ms,
	                   PT:=T#200ms,
	                   Q=>#UtilSquareErrorTON);
	
	#CheckUtilitiesTON2(IN := NOT "Utilities".Square_100ms,
	                   PT := T#200ms,
	                   Q => #UtilSquareErrorTON2);
	
	
	#ModBus_TON(IN := #ModBus_wordsave = "EPICSToPLC"."Word"[2],
	            PT := T#5s);
	
	
	IF ("Utilities".AlwaysOn = FALSE) THEN
	    "EPICS_DebuggerResult".#EPICS_Debugger_UtilitiesCall := 'ERROR: FunctionBlock: "_UilitiesFB" is called with a wrong InstanceDB. Call it with the existing iDB named: "Utilities" AND check if the System Memory bits and the System Clock byte is enabled!';
	ELSE    
	    IF (#UtilSquareErrorTON OR #UtilSquareErrorTON2) THEN
	        "EPICS_DebuggerResult".#EPICS_Debugger_UtilitiesCall := 'ERROR: FunctionBlock: "_UilitiesFB" is called with a wrong InstanceDB. Call it with the existing iDB named: "Utilities" AND check if the System Memory bits and the System Clock byte is enabled!';
	    ELSE
	        "EPICS_DebuggerResult".#EPICS_Debugger_UtilitiesCall := 'OK: EPICS Utilities works as expected.';
	        
	    END_IF;
	END_IF;
	    
	IF ("Utilities".EPICS_Device_calls_precessed) THEN
	    "EPICS_DebuggerResult".#EPICS_Debugger_DeviceCalls := 'OK: "EPICS_device_calls" is called as expected.';
	ELSE
	    "EPICS_DebuggerResult".#EPICS_Debugger_DeviceCalls := 'ERROR: "EPICS_device_calls" is not called in OB1!';
	END_IF;
	    
	IF (("EPICSToPLC"."Word"[0] = "PLCToEPICS"."Word"[0]) AND ("EPICSToPLC"."Word"[1] = "PLCToEPICS"."Word"[1])) THEN
	    "EPICS_DebuggerResult".#EPICS_Debugger_IOCHash := 'OK: IOC and PLC hash are equal.';
	ELSE    
	    "EPICS_DebuggerResult".#EPICS_Debugger_IOCHash := 'ERROR: IOC and PLC hash are NOT equal!';
	END_IF;
	
	IF (#ModBus_TON.Q) THEN
	    "EPICS_DebuggerResult".#EPICS_Debugger_ModBusHeartBeat := 'ERROR: The IOC is not sending any HeartBeat via ModBus!';
	    #ModBusOK := FALSE;
	ELSE
	    "EPICS_DebuggerResult".#EPICS_Debugger_ModBusHeartBeat := 'OK: ModBus HeartBeat is received as expected.';
	    #ModBusOK := TRUE;
	END_IF;
	
	#S7ConnTON(IN := NOT "_CommsPLC_EPICS_DB".SendDone, PT := T#3s);
	
	IF ("_CommsPLC_EPICS_DB".BytesToSend > 0) THEN
	    
	    IF (#S7ConnTON.Q) THEN
	        "EPICS_DebuggerResult".EPICS_Debugger_S7Connection := 'ERROR: EPICS S7 connection can not send Status variables!';
	        #S7OK := FALSE;
	    ELSE
	        "EPICS_DebuggerResult".EPICS_Debugger_S7Connection := 'OK: EPICS S7 works as expected.';
	        #S7OK := TRUE;
	        
	    END_IF;
	ELSE
	    "EPICS_DebuggerResult".EPICS_Debugger_S7Connection := 'OK: EPICS S7 disabled, there is no Status variable to send.';
	    #S7OK := TRUE;
	END_IF;
	
	IF (#ModBusOK AND #S7OK) THEN
	    "EPICS_DebuggerResult".EPICS_Debugger_EPICS_GeneralState := 'OK. EPICS IOC communication is ONLINE.';
	END_IF;
	
	IF (#ModBusOK AND NOT #S7OK) THEN
	    "EPICS_DebuggerResult".EPICS_Debugger_EPICS_GeneralState := 'ERROR. ModBus seems to be working but S7 TCP is blocked. Try to check your PLC router IP.';
	END_IF;
	
	IF (NOT #ModBusOK AND #S7OK) THEN
	    "EPICS_DebuggerResult".EPICS_Debugger_EPICS_GeneralState := 'ERROR. ModBus seems to be offline. Waiting for IOC to finish connecting to the PLC.';
	END_IF;
	
	IF ( NOT #ModBusOK AND NOT #S7OK) THEN
	    "EPICS_DebuggerResult".EPICS_Debugger_EPICS_GeneralState := 'ERROR. Both ModBus and S7 TCP seems to be offline. Check if your IOC is running and if it is connected to the right PLC interface. Your HardwareID comes from CCDB!';
	END_IF;
	
	"EPICS_DebuggerResult".EPICS_ModbusPort := "_CommsPLC_EPICS_DB".MBPort;
	"EPICS_DebuggerResult".EPICS_S7Port := "_CommsPLC_EPICS_DB".S7Port;
	"EPICS_DebuggerResult".EPICS_PLC_EthernetInterface :=  "_CommsPLC_EPICS_DB".InterfaceID;
	
	
	#ModBus_wordsave := "EPICSToPLC"."Word"[2];
	
	
END_FUNCTION_BLOCK
DATA_BLOCK "EPICS_DebuggerFB_iDB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"EPICS_DebuggerFB"

BEGIN

END_DATA_BLOCK
ORGANIZATION_BLOCK "EPICS_DebuggerOB"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	//Author: Miklos Boros (miklos.boros@esss.se), Copyrigth 2017-2019 by European Spallation Source, Lund
	//This block was generated by PLCFactory
	//Description: This OB is a cyclic OB called in every PLC cycle and EPICS_DebuggerFB checks the EPICS configuration.
	
	//DO NOT Modify this block!!!
	"EPICS_DebuggerFB_iDB"();
	
	
END_ORGANIZATION_BLOCK
DATA_BLOCK "EPICSToPLC"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
//########## EPICS->PLC datablock ##########
   STRUCT
      "Word" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..27] of Word;
   END_STRUCT;

BEGIN

END_DATA_BLOCK

DATA_BLOCK "PLCToEPICS"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
NON_RETAIN
//########## PLC->EPICS datablock ##########
   STRUCT
      "Word" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; } : Array[0..89] of Word;
   END_STRUCT;

BEGIN

END_DATA_BLOCK

FUNCTION "_CommsEPICS" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_TEMP
      PLC_Hash : DInt;
   END_VAR

BEGIN
	//Heartbeat PLC->EPICS
	IF "Utilities".Pulse_1s THEN
	    "PLCToEPICS"."Word"[2] := "PLCToEPICS"."Word"[2] + 1;
	    IF "PLCToEPICS"."Word"[2] >= 32000 THEN
	        "PLCToEPICS"."Word"[2] := 0;
	    END_IF;
	END_IF;

	// PLC Factory commit ID: N/A
	// PLC Hash (Generated by PLC Factory)
	#PLC_Hash := DINT#1347332123;

	// Send the PLC Hash to the EPICS IOC
	"PLCToEPICS"."Word"[1] := DINT_TO_WORD(#PLC_Hash);
	"PLCToEPICS"."Word"[0] := DINT_TO_WORD(SHR(IN := #PLC_Hash, N := 16));

	// Call the comms block to provide PLC<->EPICS comms
	"_CommsPLC_EPICS_DB"(Enable         := "Utilities".AlwaysOn,
	                     SendTrigger    := "Utilities".Pulse_200ms,
	                     BytesToSend    := 180,
	                     InterfaceID    := 72,
	                     S7ConnectionID := 256,
	                     MBConnectionID := 255,
	                     S7Port         := 2000,
	                     MBPort         := 502,
	                     PLCToEPICSData := "PLCToEPICS"."Word",
	                     EPICSToPLCData := "EPICSToPLC"."Word");

END_FUNCTION
